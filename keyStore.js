import {generateAsymmetricKey,
        AsymEncrypt, AsymDecrypt, Hash } from './asymmetric.js'

import {generateSymmetricKey,
        SymEncrypt, SymDecrypt} from './symmetric.js'

class keyStore{
  constructor(){
    // contains a list of crates each has an id and the relevent keys
    this.Store = []
  }

  #getPrivateKey(ID, stamp){
    const crate = this.#getCrate(ID)
    if(!crate)
      throw new Error('peer is not recognized')

    let block = crate.keys.asym.find((el)=> el.stamp == stamp)

    if(!block)
      throw Error('no key stamped with: ' + stamp)

    if(block.privateKey)
      return block.privateKey
    else
      throw new Error('the key was generated by remote peer, so we only have the public key')
  }

  #getPublicKey(ID, stamp){
    const crate = this.#getCrate(ID)
    if(!crate)
      throw new Error('peer is not recognized')

    let block = crate.keys.asym.find((el)=> el.stamp == stamp)


    if(!block)
      throw Error('no key stamped with: ' + stamp)

    return block.publicKey
  }

  #getKey(ID, stamp){
    const crate = this.#getCrate(ID)
    if(!crate)
      throw new Error('peer is not recognized')

    let block = crate.keys.sym.find((el)=> el.stamp == stamp)

    if(!block)
      throw Error('no key stamped with: ' + stamp)

    return block.key

  }

  #getCrate(ID){
    return this.Store.find((crate)=> crate.id == ID)
  }

  addSymKey(ID, stamp, key){
    let crate = this.#getCrate(ID)
    if(!crate){
      crate = {
        'id': ID,
        'keys':{
          'sym': [],
          'asym': []
        }
      }
      crate.keys.sym.push({'stamp': stamp, 'key': key})
      this.Store.push(crate)
    }else{
      crate.keys.sym.push({'stamp': stamp, 'key': key})
    }
  }

  addPublicKey(ID, stamp, key){
    let crate = this.#getCrate(ID)
    if(!crate){
      crate = {
        'id': ID,
        'keys':{
          'sym': [],
          'asym': []
        }
      }

      crate.keys.asym.push({
        'stamp': stamp,
        'publicKey': key,
      })
      this.Store.push(crate)
    }else{
      crate.keys.asym.push({
        'stamp': stamp,
        'publicKey': key,
      })
    }

  }

  generateSymKey(ID, stamp){
    const key = generateSymmetricKey()
    let crate = this.#getCrate(ID)
    if(!crate){
      crate = {
        'id': ID,
        'keys':{
          'sym': [],
          'asym': []
        }
      }
      crate.keys.sym.push({'stamp': stamp, 'key': key})
      this.Store.push(crate)
      return key
    }else{
      crate.keys.sym.push({'stamp': stamp, 'key': key})
      return key
    }
  }
  //returns Uint8 publicKey
  generateAsymKey(ID, stamp){
    const key = generateAsymmetricKey()
    let crate = this.#getCrate(ID)
    if(!crate){
      crate = {
        'id': ID,
        'keys':{
          'sym': [],
          'asym': []
        }
      }

      crate.keys.asym.push({
        'stamp': stamp,
        'publicKey': key[0],
        'privateKey':key[1],
      })
      this.Store.push(crate)
      return key[0]
    }else{
      crate.keys.asym.push({
        'stamp': stamp,
        'publicKey': key[0],
        'privateKey':key[1],
      })
      return key[0]
    }

  }

  Purge(ID){
    const index = this.Store.findIndex((crate)=> crate.id == ID)
    if(index != -1)
      this.Store.splice(index, 1)
    else
      throw new Error('no such ID')
  }

  removeSymKey(ID, stamp){
    // get crate index
    const index = this.Store.findIndex((crate)=> crate.id == ID)
    //if crate exists
    if(index != -1){
      let crate = this.Store[index]
      let keyIndex = crate.keys.sym.findIndex((el) => el.stamp == stamp)
      if(keyIndex != -1)
        this.Store[index].keys.sym.splice(keyIndex, 1)
      else
        throw new Error('no such Stamp')

    }else{
      throw new Error('no such ID')
    }
  }

  removeAsymKey(ID, stamp){
    // get crate index
    const index = this.Store.findIndex((crate)=> crate.id == ID)
    //if crate exists
    if(index != -1){
      let crate = this.Store[index]
      let keyIndex = crate.keys.asym.findIndex((el) => el.stamp == stamp)
      if(keyIndex != -1)
        this.Store[index].keys.asym.splice(keyIndex, 1)
      else
        throw new Error('no such Stamp')

    }else{
      throw new Error('no such ID')
    }
  }
  symetricEncrypt(ID, stamp, json){
    const key = this.#getKey(ID, stamp)
    return SymEncrypt(json, key)
  }

  aSymetricEncrypt(ID, stamp, json){
    const key = this.#getPublicKey(ID, stamp)
    return AsymEncrypt(key, json)
  }

  publicKeyEncrypt(publicKey, json){
    return AsymEncrypt(publicKey, json)
  }

  symetricDecrypt(ID, stamp, message){
    const key = this.#getKey(ID, stamp)
    return SymDecrypt(message, key)
  }

  aSymetricDecrypt(ID, stamp, message){
    const key = this.#getPrivateKey(ID, stamp)
    return AsymDecrypt(key, message)
  }
}

//--------------------------Testing-----------------------------//
/*
import {v4 as uuid4} from 'uuid'
const key_store = new keyStore()
let peers = [uuid4(), uuid4(), uuid4()]
let stamps = ['p1', 'p2', 'p3']
for(let i in peers)
  for(let j in stamps)
    key_store.generateAsymKey(peers[i], stamps[j])
console.log(key_store.Store)

const msg = {'hello': 'world'}
let enc
enc = key_store.aSymetricEncrypt(peers[0], stamps[0], msg)
console.log(enc)
console.log(key_store.aSymetricDecrypt(peers[0], stamps[0], enc))
key_store.Purge(peers[0])
key_store.removeAsymKey(peers[1], stamps[1])
console.log(key_store)
console.log(key_store.Store[0].keys)
*/
