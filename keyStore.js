import {generateAsymmetricKey,
        AsymEncrypt, AsymDecrypt, Hash } from './asymmetric.js'

import {generateSymmetricKey,
        SymEncrypt, SymDecrypt} from './symmetric.js'

//import utility functions
import pkg from "tweetnacl-util"
const { decodeUTF8, encodeUTF8, encodeBase64, decodeBase64} = pkg

class keyStore{
  constructor(){
    // contains a list of crates each has an id and the relevent keys
    this.Store = []
  }

  #getPrivateKey(ID, stamp){
    const crate = this.#getCrate(ID)
    if(!crate)
      throw new Error('no such ID')

    let block = crate.keys.asym.find((el)=> el.stamp == stamp)

    if(!block)
      throw Error('no key stamped with: ' + stamp)

    if(block.privateKey)
      return decodeBase64(block.privateKey)
    else
      throw new Error('the key was generated by remote peer, so we only have the public key')
  }

  #getPublicKey(ID, stamp){
    const crate = this.#getCrate(ID)
    if(!crate)
      throw new Error('no such ID')

    let block = crate.keys.asym.find((el)=> el.stamp == stamp)


    if(!block)
      throw Error('no key stamped with: ' + stamp)

    return decodeBase64(block.publicKey)
  }

  #getKey(ID, stamp){
    const crate = this.#getCrate(ID)
    if(!crate)
      throw new Error('no such ID')

    let block = crate.keys.sym.find((el)=> el.stamp == stamp)

    if(!block)
      throw Error('no key stamped with: ' + stamp)

    return decodeBase64(block.key)

  }

  #getCrate(ID){
    return this.Store.find((crate)=> crate.id == ID)
  }

  addSymKey(ID, stamp, key){
    let crate = this.#getCrate(ID)
    if(!crate){
      crate = {
        'id': ID,
        'keys':{
          'sym': [],
          'asym': []
        }
      }
      crate.keys.sym.push({'stamp': stamp, 'key': key})
      this.Store.push(crate)
    }else{
      crate.keys.sym.push({'stamp': stamp, 'key': key})
    }
  }

  addPublicKey(ID, stamp, key){
    let crate = this.#getCrate(ID)
    if(!crate){
      crate = {
        'id': ID,
        'keys':{
          'sym': [],
          'asym': []
        }
      }

      crate.keys.asym.push({
        'stamp': stamp,
        'publicKey': key,
      })
      this.Store.push(crate)
    }else{
      crate.keys.asym.push({
        'stamp': stamp,
        'publicKey': key,
      })
    }

  }

  generateSymKey(ID, stamp){
    const key = encodeBase64(generateSymmetricKey())
    let crate = this.#getCrate(ID)
    if(!crate){
      crate = {
        'id': ID,
        'keys':{
          'sym': [],
          'asym': []
        }
      }
      crate.keys.sym.push({'stamp': stamp, 'key': key})
      this.Store.push(crate)
      return key
    }else{
      crate.keys.sym.push({'stamp': stamp, 'key': key})
      return key
    }
  }
  //returns Uint8 publicKey
  generateAsymKey(ID, stamp){
    const key = generateAsymmetricKey()
    const publicKey = encodeBase64(key[0])
    const privateKey = encodeBase64(key[0])
    let crate = this.#getCrate(ID)
    if(!crate){
      crate = {
        'id': ID,
        'keys':{
          'sym': [],
          'asym': []
        }
      }

      crate.keys.asym.push({
        'stamp': stamp,
        'publicKey': publicKey,
        'privateKey': privateKey,
      })
      this.Store.push(crate)
      return publicKey
    }else{
      crate.keys.asym.push({
        'stamp': stamp,
        'publicKey': publicKey,
        'privateKey':privateKey,
      })
      return publicKey
    }

  }

  Purge(ID){
    const index = this.Store.findIndex((crate)=> crate.id == ID)
    if(index != -1)
      this.Store.splice(index, 1)
    else
      throw new Error('no such ID')
  }

  removeSymKey(ID, stamp){
    // get crate index
    const index = this.Store.findIndex((crate)=> crate.id == ID)
    //if crate exists
    if(index != -1){
      let crate = this.Store[index]
      let keyIndex = crate.keys.sym.findIndex((el) => el.stamp == stamp)
      if(keyIndex != -1)
        this.Store[index].keys.sym.splice(keyIndex, 1)
      else
        throw new Error('no such Stamp')

    }else{
      throw new Error('no such ID')
    }
  }

  removeAsymKey(ID, stamp){
    // get crate index
    const index = this.Store.findIndex((crate)=> crate.id == ID)
    //if crate exists
    if(index != -1){
      let crate = this.Store[index]
      let keyIndex = crate.keys.asym.findIndex((el) => el.stamp == stamp)
      if(keyIndex != -1)
        this.Store[index].keys.asym.splice(keyIndex, 1)
      else
        throw new Error('no such Stamp')

    }else{
      throw new Error('no such ID')
    }
  }
  symmetricEncrypt(ID, stamp, json){
    const key = this.#getKey(ID, stamp)
    return SymEncrypt(json, key)
  }

  aSymmetricEncrypt(ID, stamp, json){
    const key = this.#getPublicKey(ID, stamp)
    return AsymEncrypt(key, json)
  }

  publicKeyEncrypt(publicKey, json){
    return AsymEncrypt(publicKey, json)
  }

  symmetricDecrypt(ID, stamp, message){
    const key = this.#getKey(ID, stamp)
    return SymDecrypt(message, key)
  }

  aSymmetricDecrypt(ID, stamp, message){
    const key = this.#getPrivateKey(ID, stamp)
    return AsymDecrypt(key, message)
  }

  // checks if peer with ID
  // already posese the key with "stamp"
  checkStamp(ID, stamp){
    try{
      key = this.#getKey(ID, stamp)
      if(key)
        return true
      else
        return false
    }catch(e){
      return false
    }
  }
}

export default keyStore
//--------------------------Testing-----------------------------//
/*
import {v4 as uuid4} from 'uuid'
const key_store = new keyStore()
let peers = [uuid4(), uuid4(), uuid4()]
let stamps = ['p1', 'p2', 'p3']
for(let i in peers)
  for(let j in stamps)
    key_store.generateAsymKey(peers[i], stamps[j])
console.log(key_store.Store)

const msg = {'hello': 'world'}
let enc
enc = key_store.aSymetricEncrypt(peers[0], stamps[0], msg)
console.log(enc)
console.log(key_store.aSymetricDecrypt(peers[0], stamps[0], enc))
key_store.Purge(peers[0])
key_store.removeAsymKey(peers[1], stamps[1])
console.log(key_store)
console.log(key_store.Store[0].keys)
*/
